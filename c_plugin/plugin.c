/*
 This is an example of how you can write a plugin for physim. This plugin
 contains one element, cdrag. cdrag is relatively simple, it applies a
 fixed drag force to entities. However, this element demonstrates many
 of the fundamentals of the plugin system in physim. 

 cdrag is a transform element. There are many other types of elements in
 physim, but they rely on having ownership of the state of the system or
 they rely on things in Rust which do not have a stable C ABI. As such, 
 you can't implement the other types of elements.

 physim.h is generated by with the cbindgen tool. To compile the plugin
 you need to link against lphysim_core
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "physim.h"

/*****************************************************************************
 * These methods are boiler plate for registering elements in your plugin.
 *****************************************************************************/

 /* For C plugins, PLUGIN_ABI_INFO has to be "C". Phyim will attempt to
    validate that the plugin was compiled with the same version of rust
    when the plugin is loaded, but in the case of C, all bets are off. */
const char* PLUGIN_ABI_INFO = "C";

/* PLUGIN_ELEMENTS is a comma separated list of elements. Physim will
   parse this to know what to look for in the plugin library. This tells
   physim to look for cdrag_get_api */
const char* PLUGIN_ELEMENTS = "cdrag";

/* Global bus target for passing messages onto the message bus. Physim will
   set this during the pipeline's life cycle using set_callback_target */
static void* GLOBAL_BUS_TARGET = NULL;

const char* get_plugin_abi_info(void) {
    return PLUGIN_ABI_INFO;
}

const char* register_plugin(void) {
    return PLUGIN_ELEMENTS;
}

void set_callback_target(void* target) {
    if (target == NULL) {
        fprintf(stderr, "Error: callback target is null\n");
        abort();
    }
    GLOBAL_BUS_TARGET = target;
}

/*****************************************************************************
 * These methods give your element behaviour
 *****************************************************************************/

/* The DragTransform maintains the element's state. */
typedef struct {
    double drag;
} DragTransform;


/* Physim will pass a json object to elements which they can parse as
   key/value pairs (value can be anything valid in json) */
void* cdrag_init(const uint8_t* config, size_t len) {
    if (config == NULL) {
        return NULL;
    }
    /*
    TODO: parse the json config assign it to the transform
    */
   (void)len; // Unused

    
    DragTransform* transform = (DragTransform*)malloc(sizeof(DragTransform));
    if (transform == NULL) {
        return NULL;
    }
    
    transform->drag = 1.0;
    return (void*)transform;
}

/* Transform elements call this function every time the they need to update
   the state of the system. state and acceleration should be the same length
   but hypothetically they can be different if physim has a bug  */
void cdrag_transform(const void* obj, const Entity* state, size_t state_len,
                     Acceleration* acceleration, size_t acceleration_len) {
    if (obj == NULL) {
        return;
    }
    const DragTransform* el = (const DragTransform*)obj;
    (void)state_len; // Unused
    

    for (size_t i = 0; i < acceleration_len; i++) {
        Acceleration a = {
            .x = -el->drag * state[i].vx,
            .y = -el->drag * state[i].vy,
            .z = -el->drag * state[i].vz
        };

        acceleration[i].x += a.x;
        acceleration[i].y += a.y;
        acceleration[i].z += a.z;
    }
    
    // Post message to bus
    if (GLOBAL_BUS_TARGET != NULL) {
        CMessage msg;
        msg.topic = "cDragTransform";
        msg.message = "transformed";
        msg.priority = Normal;
        msg.sender_id = (size_t)obj;
        msg.origin = C;
        post_bus_callback(GLOBAL_BUS_TARGET, msg);
    }
}

/* This is called by Physim when it is finished using the element */
void cdrag_destroy(void* obj) {
    if (obj == NULL) {
        return;
    }
    free(obj);
}

/* This is to provide documentation about the element to users of physcan. 
   It must be key/value pairs which are strings. It doesn't actually
   affect the element when it runs in a simulation. */
char* cdrag_get_property_descriptions(void* obj, RustStringAllocFn alloc) {
    if (obj == NULL) {
        return NULL;
    }
    return alloc("{\"foo\": \"bar\"}");
}

/* The message bus is a way of broadcasting information throughout the
   pipeline so that elements can talk to each other.  */
void cdrag_recv_message(void* obj, const struct CMessage* msg) {
    if (obj == NULL) {
        return;
    }
    (void)msg; // Unused
    // Example of printing out messages 
    // printf("[MESSAGE] - sender: %zx - topic: %s - priority: %d\n", msg->sender_id, msg->topic , msg->priority);    
}

/* After the initialisation of an element, it gets 1 chance to broadcast some
   information to the rest of the pipeline which will be received before the
   simulation starts.  */
void cdrag_post_configuration_messages(void* obj) {
    if (obj == NULL) {
        return;
    }    
}

/* This wires up the element and makes it an "object"  */
const TransformElementAPI* cdrag_get_api(void) {
    static TransformElementAPI api = {
        .init = cdrag_init,
        .transform = cdrag_transform,
        .destroy = cdrag_destroy,
        .get_property_descriptions = cdrag_get_property_descriptions,
        .recv_message = cdrag_recv_message,
        .post_configuration_messages = cdrag_post_configuration_messages,
    };
    return &api;
}

/* This provides user's of physcan with some helpful information about
   the element as well as letting physim store it in it's pool of
   registered elements. 

   RustStringAllocFn lets you allocate strings on the heap in Rust. This 
   is required to prevent memory leaks and strange ownership problems */
ElementMetaFFI cdrag_register(RustStringAllocFn alloc) {
    ElementMetaFFI meta;
    meta.kind = Transform; // IMPORTANT, none of the other kinds of elements have a C API.
    meta.name = alloc("cdrag");
    meta.plugin = alloc("cplugin");
    meta.version = alloc("0.0.1");
    meta.license = alloc("MIT");
    meta.author = alloc("Joseph Briggs <jhbriggs23@gmail.com>");
    meta.blurb = alloc("Example of a C plugin");
    meta.repo = alloc("https://github.com/jhb123/physim");
    return meta;
}
